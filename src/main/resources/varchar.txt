只要调用了这两个关闭方法的一个当所有的任务都关闭后才表示线程池关闭成功至于应该调用哪一种方法来关闭线程池应该由提交到线程池的任务特性决定通常调用方法来关闭线程池如果任务不一定执行完则可以调用方法4合理配置线程池要想合理地配置线程池首先要分析任务特性任务的性质：密集型任务、密集型任务和混合型任务任务的优先级：高、中和低任务的执行时间：长、中和短任务的依赖性：是否依赖其他系统资源如数据库连接性质不同的任务可以用不同规模的线程池分开处理密集型任务应该配置尽可能少的线程如配置个线程位的个数而密集型任务线程并不是一直在执行任务则应配置尽可能多的线程如混合型任务如果可以拆分将其拆分成一个密集型任务和一个密集型任务只要这两个任务执行的时间相差不是太大那么分解后执行的吞吐量将高于串行执行的吞吐量优先级不同的任务可以交给优先级队列来处理执行时间不同的任务可以交给不同规模的线程池来处理依赖数据库的任务因此线程提交后需要等待数据库返回结果等待的时间越长则空闲时间越长那么线程数应该设置的越大这样能更好滴利用
只要调用了这两个关闭方法的一个当所有的任务都关闭后才表示线程池关闭成功至于应该调用哪一种方法来关闭线程池应该由提交到线程池的任务特性决定通常调用方法来关闭线程池如果任务不一定执行完则可以调用方法4合理配置线程池要想合理地配置线程池首先要分析任务特性任务的性质：密集型任务、密集型任务和混合型任务任务的优先级：高、中和低任务的执行时间：长、中和短任务的依赖性：是否依赖其他系统资源如数据库连接性质不同的任务可以用不同规模的线程池分开处理密集型任务应该配置尽可能少的线程如配置个线程位的个数而密集型任务线程并不是一直在执行任务则应配置尽可能多的线程如混合型任务如果可以拆分将其拆分成一个密集型任务和一个密集型任务只要这两个任务执行的时间相差不是太大那么分解后执行的吞吐量将高于串行执行的吞吐量优先级不同的任务可以交给优先级队列来处理执行时间不同的任务可以交给不同规模的线程池来处理依赖数据库的任务因此线程提交后需要等待数据库返回结果等待的时间越长则空闲时间越长那么线程数应该设置的越大这样能更好滴利用


@Override
   public void channelRead(ChannelHandlerContext ctx, Object msg) {
       ctx.write(msg);
   }

   @Override
   public void channelReadComplete(ChannelHandlerContext ctx) {
       ctx.flush();
   }

   @Override
   public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
       // Close the connection when an exception is raised.
       cause.printStackTrace();
       ctx.close();
   }
   
   
